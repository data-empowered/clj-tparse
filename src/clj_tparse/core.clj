(ns clj-tparse.core
  (:require [instaparse.core :as insta]
            [clojure.set :refer [map-invert]]
            [clojure.string :as string]))

(declare process-resource resource configure-parser vectormap->rdf-edn)

;; state-atoms
(def prefix-counter
  "Atom to make sure on the fly generated prefixes are unqiue"
  (atom 0))

(def base-prefix
  "Namepart for building on the fly prefixes, when required. Forms full prefix together with digit from prefix-counter"
  "ns")

(def dataset
  "Atom contains the full dataset, generated by parse-statements."
  (atom {:prefix  {}
         :triples #{}}))

(def triple
  "Atom is a place holder for the resources of the triple being parsed. Once the triple is parsed,
  the result is transfered into the dataset"
  (atom []))

;; define parsing environment
(def parsing-prefixes
  "Atom contains the prefixes related to the parsing of triples. The prefixes contained in this atom show what is
  currently known and true for the triple being parsed."
  (atom {}))

(def turtle-config-file
  "Turtle Definition file, used by insta-parse to enable it to parse turtle-files."
  "resources/rdf-turtle-spec.txt")

;; Parser definition
(comment (def input-file "resources/example10.ttl"))

;; Regex definitions
(def parser-def
  "Define parser"
  (insta/parser turtle-config-file))

(def match-url
  "Regex for url's. Since insta-parse does already do a more thorough check on the url, this regex is simplified
  for the usecase it is needed for"
  (partial re-matches #"^(http[^\s]+[/#])([^/#].*)$"))

(defn build-prefix
  []
  (let [p-cnt (swap! prefix-counter inc)
        prefix (str base-prefix p-cnt)]
    (keyword prefix)))

(defn register-prefix
  [prefix iri]
  (swap! dataset update :prefix conj {prefix iri}))

(defn return-prefix
  "Returns the correct prefix for a namespace.
  In case a prefix is supplied, it retrieves the namespace, to make sure it isn't used already.
  When the namespace is already used, the existing prefix for this namespace will be supplied.
  Otherwhise the prefix with it's original namespace will be registered."
  [nspace]
  (if (= "_" nspace)
    (keyword nspace)
    (let [ns (if (= ":" nspace) "local" nspace)
          lp-map @parsing-prefixes
          gp-map (@dataset :prefix)
          absolute-url (or (first (match-url ns)) (lp-map (keyword ns)) (gp-map (keyword ns)))
          local-nses (map-invert lp-map)
          nses (map-invert gp-map)
          a (or (and (local-nses absolute-url) 2) 0)
          b (or (and (nses absolute-url) 1) 0)
          g-prefix (nses absolute-url)
          l-prefix (local-nses absolute-url)]
      (condp = (+ a b)
        0 (build-prefix)
        1 g-prefix
        2 (let [prefix (or (if (gp-map l-prefix)
                             false
                             l-prefix)
                           (build-prefix))]
            (register-prefix prefix absolute-url) prefix)
        3 g-prefix
        (println "Return-prefix - Unexpected state value:" (+ a b))))))

(defn prefixed-name
  "Returns the correct namespaced keyword for supplied RDF turtle prefix-name '<prefix>:<name>'. Since Turtle allows for the re-definition of prefixes,
  a different namespace than expected might be returned. For correctness of the namespace, check the prefixes in the dataset."
  [value]
  (let [[p n] (rest (re-matches #"^([^\s]*):([^\s]+)" (apply str value)))
        n (if (Character/isDigit (first n))
            (str "#-remove-#" n)
            n)
        prefix (name (return-prefix (or (not-empty p) (first value))))]
    (if (= (keyword ":") prefix)
      (keyword (str prefix n))
      (keyword (str prefix "/" n)))))

(defn iri
  "Returns keyword or string, depending on iri supplied.
  For example, it returns e-mail adresses as strings"
  [value]
  (if (vector? value)
    (let [v (last value)]
      (condp = (value 0)
        :ref (if (re-matches #"^([^\s/@]+)"
                             (apply str v))
               (keyword (str "base/" v))
               (apply str v))
        :PrefixedName (prefixed-name (rest value))
        (println "Iri - The keyword at position 0 is unknown:" value)))
    (let [lc (last value)]
      (if (or (= \/ lc) (= \# lc) (= \? lc))
        value
        (let [[ns term] (rest (match-url value))
              prefix (return-prefix ns)]
          (swap! dataset update :prefix conj {prefix ns})
          (keyword (str (name prefix) "/" term)))))))

(defn string-literal-types
  "Returns vector with keys :value, :lang, or :type. Depending on the data supplied"
  [slt]
  (condp = (slt 0)
    :string [:value (apply str (rest slt))]
    :langtag [:lang (apply str (rest (rest slt)))]
    :iri [:type (iri (slt 1))]
    (println "string-literal-types no match - slt:" slt)))

(defn process-rdf-literal
  "Returns literal as string or map."
  [literal]
  (let [c (count literal)]
    (if (> c 1)
      (into {} (mapv string-literal-types literal))
      (apply str (rest (first literal))))))

(defn process-sub-resource
  [bn]
  (condp = (bn 0)
    :predicateObjectList (map process-sub-resource (rest bn))
    :predicate (resource (bn 1))
    :objectList (apply process-sub-resource (rest bn))
    :object (resource (bn 1))
    (println "process-sub-resource - *no match* - bn 0:" (bn 0) "- bn:" bn "- triple:" @triple)))

(defn resource-pair
  [result resource]
  (let [r (process-sub-resource resource)
        l (last result)]
    (if (nil? l)
      (conj result r)
      (if (= (type l) clojure.lang.PersistentVector)
        (conj result r)
        (conj (subvec result 0 (- (count result) 1)) [l r])))))

(defn resource
  "Returns the edn version of a resource."
  [r]
  (condp = (r 0)
    :iri (iri (r 1))
    :a (do (register-prefix :rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#")
           (keyword "rdf/type"))
    :literal (resource (r 1))
    :RDFLiteral (process-rdf-literal (vec (rest r)))
    :integer (Integer. (apply str (rest r)))
    :decimal (BigDecimal. (apply str (rest r)))
    :double (BigDecimal. (apply str (rest r)))
    :BooleanLiteral (r 1)
    :blankNodePropertyList (into {}
                                 (reduce resource-pair [] (rest (r 1))))
    :BlankNode (if (= (apply str (rest r)) "[]")
                 {:empty :blank-node}
                 (prefixed-name (rest r)))
    :collection (mapv process-sub-resource (rest r))))

(defn process-resource
  [ti]
  (condp = (ti 0)
    :triples (mapv process-resource (rest ti))
    :subject (do
               (reset! triple [])
               (swap! triple assoc 0 (resource (ti 1))))
    :predicateObjectList (do
                           (swap! triple subvec 0 1)
                           (mapv process-resource (rest ti)))
    :predicate (swap! triple assoc 1 (resource (ti 1)))
    :objectList (do
                  (swap! triple subvec 0 2)
                  (mapv process-resource (rest ti)))
    :object (do
              (swap! triple assoc 2 (resource (ti 1)))
              (swap! dataset update :triples conj @triple))
    :blankNodePropertyList (swap! triple conj
                                  (into {}
                                        (reduce resource-pair [] (rest (ti 1)))))
    (println "process-resource - *no match* - ti 0:" (ti 0) "- ti:" ti "- triple:" @triple)))

(defn process-triples
  [symbol]
  (mapv process-resource symbol))

(defn prefix-namespace
  "Returns absolute url namespace.
  When nspace is a vector it asumes that position zero has
  the :ref keyword and position one of the vector contains the relative path of the namespace"
  [nspace]
  (if (vector? nspace)
    (str (:base (:prefix @dataset)) (nspace 1))
    nspace))

(defn process-prefix
  [statement]
  (let [e (count statement)]
    (cond
      (= e 3) (swap! parsing-prefixes conj
                     {(keyword (if (= ":" (statement 1)) "local" (statement 1))) (prefix-namespace ((statement 2) 1))})
      (= e 4) (swap! parsing-prefixes conj
                     {(keyword (statement 1)) (prefix-namespace ((statement 3) 1))})
      :else (println "Incorrect amount of elements, count is:" e "The failing statement:" statement))))

(defn process-base
  [base]
  (swap! dataset update :prefix conj {:base ((base 1) 1)}))

(defn get-content
  [content-holder]
  (slurp content-holder))

(defn parse-turtle
  "Parses turtle input. Returns triples as hiccup-style nested vectors with keywords."
  [content]
  (insta/parse parser-def (get-content content)))

(defn parse-statements
  "Returns dataset in edn triples, for any statement supplied.
  Statements are hiccup-style nested-vector triples  as returned by parse-turtle."
  [vm]
  (last
    (for [symbol (rest vm)]
      (let [kw (first symbol)]
        (if (keyword? kw)
          (condp = kw
            :triples (process-triples symbol)
            :prefix (process-prefix symbol)
            :base (process-base symbol)
            (println "Can't make any sense of this input -kw " kw " -symbol" symbol)))
        @dataset))))